

// Creates a profile (required for enrollment)
// Returns a promises that resolves to a profileId
export const createProfile = () => fetch(apiUrl('/identificationProfiles'), {
    method: 'POST',
    headers: {
      ...headers.json,
      ...headers.key
    },
    body: JSON.stringify({
      "locale":"en-us"
    })
  })
  .then(asJSON)
  .then(x => x.identificationProfileId)

// Creates an enrollment for a profile (profileId is generated by createProfile)
export const createEnrollment = (profileId, wavBlob) => {
  return fetch(apiUrl('/identificationProfiles/'+ profileId + '/enroll?shortAudio=true'), {
    method: 'POST',
    headers: {
      ...headers.key,
      "Content-Type": "audio/x-wav"
    },
    body: wavBlob
  })
  .then(asLocation)
  .then(waitForOperation)
}

// Searches for profileIds in a given wav file
// Returns a promise that resolves to an object with { identifiedProfileId, confidence (Low, Normal, High) }
// identifiedProfileId will be 0000-0000-0000-0000 if no profile identified
export const identify = (profileIds, wavBlob ) =>
  fetch(apiUrl('/identify?identificationProfileIds=' + profileIds.join(',') + '&shortAudio=true'), {
    method: 'POST',
    headers: {
      ...headers.key,
      "Content-Type": "audio/x-wav"
    },
    body: wavBlob
  })
  .then(asLocation)
  .then(waitForOperation)

const waitForOperation = location =>
  operationStatus(location).then(operation =>
    operation.status === 'running' || operation.status === 'notstarted'
      ? wait(1000).then(() => waitForOperation(location))
      : operation.processingResult)


const subscriptionKey = 'c2e8e975440c4375afcf446b05e0320e'
const apiUrl = path => 'https://westus.api.cognitive.microsoft.com/spid/v1.0' + path
const headers = {
  key: { 'Ocp-Apim-Subscription-Key': subscriptionKey },
  json: { 'Content-Type': 'application/json' }
}

// Extracts the location url from a response from a request that creates
// an operation
const asLocation = response => {
  let headers = Array.from(response.headers.entries()).map(x => ({ name: x[0], value: x[1] }))
  let operationLocation = headers.find(h => h.name === 'operation-location').value
  return operationLocation
}

const asJSON = response => response.json()

const operationStatus = (location) =>
  fetch(location, {
    headers: {
      ...headers.key
    }
  }).then(asJSON)

const wait = delay => new Promise((resolve) => {
  setTimeout(resolve, delay)
})
